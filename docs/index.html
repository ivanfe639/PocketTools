<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genealogia Pro - Visualizador de √Årbol Familiar</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&family=Playfair+Display:ital,wght@0,700;1,700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary: #6366f1;
            --primary-light: #818cf8;
            --secondary: #ec4899;
            --bg-dark: #0f172a;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --card-bg: #1e293b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Outfit', sans-serif;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            min-height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Animated Background */
        .bg-animate {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: radial-gradient(circle at 50% 50%, #1e1b4b 0%, #0f172a 100%);
            /* Grid Pattern for infinite feel */
            background-image:
                radial-gradient(circle at 50% 50%, #1e1b4b 0%, #0f172a 100%),
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 100% 100%, 50px 50px, 50px 50px;
        }

        .blob {
            position: absolute;
            width: 400px;
            height: 400px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            filter: blur(80px);
            border-radius: 50%;
            opacity: 0.15;
            animation: move 20s infinite alternate;
        }

        @keyframes move {
            from {
                transform: translate(-10%, -10%);
            }

            to {
                transform: translate(20%, 20%) scale(1.1);
            }
        }

        /* Header */
        header {
            padding: 1.5rem 3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--glass);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--glass-border);
            z-index: 10;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 1.8rem;
            background: linear-gradient(to right, #fff, var(--primary-light));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls {
            display: flex;
            gap: 1rem;
        }

        button {
            padding: 0.6rem 1.2rem;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            background: var(--glass);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        button:hover {
            background: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        button.accent {
            background: var(--primary);
            border: none;
        }

        /* Main Workspace */
        main {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            cursor: grab;
            position: relative;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #tree-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            pointer-events: none;
            overflow: visible;
            z-index: 1;
            /* Below nodes */
        }

        #nodes-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            pointer-events: none;
            /* Let clicks pass to canvas except on nodes */
            z-index: 2;
        }

        .node {
            position: absolute;
            min-width: 180px;
            padding: 1rem;
            background: var(--card-bg);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            pointer-events: auto;
            /* Enable clicks on nodes */
        }

        .node:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 35px rgba(99, 102, 241, 0.2);
            border-color: var(--primary-light);
        }

        .node .name {
            font-weight: 600;
            display: block;
            margin-bottom: 0.2rem;
        }

        .node .role {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal {
            background: var(--card-bg);
            padding: 2.5rem;
            border-radius: 24px;
            width: 400px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .modal h2 {
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 1.2rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        input,
        select {
            width: 100%;
            padding: 0.8rem;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            color: white;
            outline: none;
        }

        input:focus {
            border-color: var(--primary);
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 2rem;
        }

        /* Connections */
        .line {
            stroke: var(--text-muted);
            stroke-width: 2;
            fill: none;
            opacity: 0.3;
        }
    </style>
</head>

<body>
    <div class="bg-animate">
        <div class="blob" style="top: 10%; left: 10%;"></div>
        <div class="blob" style="bottom: 10%; right: 10%; animation-delay: -5s;"></div>
    </div>

    <header>
        <h1>ArbolGeneal√≥gico.v3</h1>
        <div class="controls">
            <button onclick="addRootPerson()">+ Agregar Patriarca/Matriarca</button>
            <button onclick="autoLayout()">ü™Ñ Auto-ordenar</button>
            <button class="accent" onclick="exportData()">Exportar JSON</button>
            <button onclick="document.getElementById('import-input').click()">Importar JSON</button>
            <button onclick="downloadTreeImage()">üì∏ Descargar Imagen</button>
            <input type="file" id="import-input" style="display: none" accept=".json" onchange="handleFile(event)">
        </div>
    </header>

    <main>
        <div id="canvas-container">
            <svg id="tree-svg"></svg>
            <div id="nodes-container"></div>
        </div>
    </main>

    <!-- Modal for adding/editing person -->
    <div id="person-modal" class="modal-overlay">
        <div class="modal">
            <h2 id="modal-title">Agregar Persona</h2>
            <div class="form-group">
                <label>Nombre Completo</label>
                <input type="text" id="person-name" placeholder="Ej. Juan P√©rez">
            </div>
            <div class="form-group">
                <label>Parentesco</label>
                <select id="person-relation">
                    <option value="child">Hijo/a de...</option>
                    <option value="partner">Pareja de...</option>
                    <option value="parent">Padre/Madre de...</option>
                </select>
            </div>
            <div class="form-group" id="parent-select-group">
                <label>Relacionado con</label>
                <select id="parent-person"></select>
            </div>
            <div class="modal-actions">
                <button onclick="closeModal()">Cancelar</button>
                <button class="accent" onclick="savePerson()">Guardar</button>
            </div>
        </div>
    </div>

    <script>
        // Data Structures
        let people = [];
        let connections = [];
        let nextId = 1;

        // Viewport handling
        let scale = 1;
        let offset = { x: 0, y: 0 };
        const canvas = document.getElementById('canvas-container');
        const nodesContainer = document.getElementById('nodes-container');
        const svg = document.getElementById('tree-svg');

        // Initial State
        function init() {
            // Drag and drop for the whole canvas
            let isDragging = false;
            let startPos = { x: 0, y: 0 };

            canvas.addEventListener('mousedown', (e) => {
                // Button 1 is the middle click (mouse wheel)
                if (e.button === 1) {
                    e.preventDefault(); // Prevent default scroll-icon behavior
                    isDragging = true;
                    startPos = { x: e.clientX, y: e.clientY };
                    canvas.style.cursor = 'grabbing';
                }
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - startPos.x;
                const dy = e.clientY - startPos.y;
                offset.x += dx;
                offset.y += dy;
                startPos = { x: e.clientX, y: e.clientY };
                updateView();
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });

            // Zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                scale *= delta;
                scale = Math.min(Math.max(0.1, scale), 3);
                updateView();
            });

            // Keyboard navigation
            window.addEventListener('keydown', (e) => {
                const step = 50 / scale; // Move more at low zoom, less at high zoom
                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        offset.y += step;
                        updateView();
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        offset.y -= step;
                        updateView();
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        offset.x += step;
                        updateView();
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        offset.x -= step;
                        updateView();
                        break;
                }
            });
        }

        function updateView() {
            const transform = `translate(${offset.x}px, ${offset.y}px) scale(${scale})`;
            nodesContainer.style.transform = transform;
            nodesContainer.style.transformOrigin = '0 0';
            svg.style.transform = transform;
            svg.style.transformOrigin = '0 0';

            // Move background grid slightly for parallax effect / infinite feel
            const bgAnimate = document.querySelector('.bg-animate');
            bgAnimate.style.backgroundPosition = `center center, ${offset.x}px ${offset.y}px, ${offset.x}px ${offset.y}px`;
        }

        // Modal Logic
        function openModal(editId = null, relationType = null, relativeId = null) {
            const modal = document.getElementById('person-modal');
            const parentSelect = document.getElementById('parent-person');
            modal.style.display = 'flex';

            // Populate select
            parentSelect.innerHTML = '<option value="">Ninguno</option>';
            people.forEach(p => {
                parentSelect.innerHTML += `<option value="${p.id}">${p.name}</option>`;
            });

            if (relativeId) parentSelect.value = relativeId;
            if (relationType) document.getElementById('person-relation').value = relationType;
        }

        function closeModal() {
            document.getElementById('person-modal').style.display = 'none';
            document.getElementById('person-name').value = '';
        }

        function addRootPerson() {
            const name = prompt("Nombre de la persona ra√≠z:");
            if (name) {
                const person = {
                    id: nextId++,
                    name: name,
                    x: window.innerWidth / 2 - 90,
                    y: 100,
                    relations: []
                };
                people.push(person);
                render();
            }
        }

        function savePerson() {
            const name = document.getElementById('person-name').value;
            const relation = document.getElementById('person-relation').value;
            const relativeId = parseInt(document.getElementById('parent-person').value);

            if (!name) return alert("Ingresa un nombre");

            const relative = people.find(p => p.id === relativeId);
            let x = 0, y = 0;

            if (relative) {
                if (relation === 'child') {
                    x = relative.x + (Math.random() * 200 - 100);
                    y = relative.y + 150;
                } else if (relation === 'parent') {
                    x = relative.x + (Math.random() * 200 - 100);
                    y = relative.y - 150;
                } else {
                    x = relative.x + 220;
                    y = relative.y;
                }
            }

            const person = {
                id: nextId++,
                name: name,
                x: x || 100,
                y: y || 100,
                parentId: relation === 'child' ? relativeId : null,
                partnerId: relation === 'partner' ? relativeId : null
            };

            people.push(person);
            if (relativeId) {
                if (relation === 'parent') {
                    relative.parentId = person.id;
                    connections.push({
                        from: person.id,
                        to: relativeId,
                        type: 'child'
                    });
                } else if (relation === 'partner') {
                    relative.partnerId = person.id;
                    connections.push({
                        from: relativeId,
                        to: person.id,
                        type: relation
                    });
                } else {
                    connections.push({
                        from: relativeId,
                        to: person.id,
                        type: relation
                    });
                }
            }

            closeModal();
            render();
        }

        function render() {
            nodesContainer.innerHTML = '';
            svg.innerHTML = '';

            people.forEach(person => {
                const div = document.createElement('div');
                div.className = 'node';
                div.style.left = person.x + 'px';
                div.style.top = person.y + 'px';
                div.innerHTML = `
                    <span class="name">${person.name}</span>
                    <span class="role">${person.parentId ? 'Hijo/a' : (person.partnerId ? 'Pareja' : 'Ra√≠z')}</span>
                    <div style="margin-top: 10px; font-size: 0.7rem; display: flex; gap: 5px; justify-content: center;">
                        <button onclick="openModal(null, 'parent', ${person.id})" style="padding: 2px 5px; font-size: 10px;">+ Padre</button>
                        <button onclick="openModal(null, 'child', ${person.id})" style="padding: 2px 5px; font-size: 10px;">+ Hijo</button>
                        <button onclick="openModal(null, 'partner', ${person.id})" style="padding: 2px 5px; font-size: 10px;">+ Pareja</button>
                        <button onclick="deletePerson(${person.id})" style="padding: 2px 5px; font-size: 10px; background: rgba(239, 68, 68, 0.2); border-color: rgba(239, 68, 68, 0.4);">X</button>
                    </div>
                `;

                // DRAG NODES (Simple)
                let nodeDragging = false;
                div.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    nodeDragging = true;
                });

                window.addEventListener('mousemove', (e) => {
                    if (!nodeDragging) return;
                    person.x += e.movementX / scale;
                    person.y += e.movementY / scale;
                    div.style.left = person.x + 'px';
                    div.style.top = person.y + 'px';
                    updateConnections();
                });

                window.addEventListener('mouseup', () => {
                    nodeDragging = false;
                });

                nodesContainer.appendChild(div);
            });

            updateConnections();
        }

        function deletePerson(id) {
            const person = people.find(p => p.id === id);
            if (!person) return;

            if (confirm(`¬øEst√°s seguro de que quieres eliminar a ${person.name}?`)) {
                // Remove from people array
                people = people.filter(p => p.id !== id);

                // Remove from connections
                connections = connections.filter(c => c.from !== id && c.to !== id);

                // Clean up relations in other people
                people.forEach(p => {
                    if (p.parentId === id) p.parentId = null;
                    if (p.partnerId === id) p.partnerId = null;
                });

                render();
            }
        }

        function autoLayout() {
            if (people.length === 0) return;

            const HORIZONTAL_SPACING = 220;
            const VERTICAL_SPACING = 250;
            const SUBTREE_MARGIN = 90; // Incrementado 10px m√°s a petici√≥n

            // 1. Map children and partners
            const childrenMap = {};
            const partners = {};
            people.forEach(p => {
                const pId = parseInt(p.id);
                if (p.parentId) {
                    const parentId = parseInt(p.parentId);
                    if (!childrenMap[parentId]) childrenMap[parentId] = [];
                    childrenMap[parentId].push(pId);
                }
                if (p.partnerId) partners[pId] = parseInt(p.partnerId);
            });

            // 2. Helper to get all children of a couple or person
            function getDescendants(personId) {
                const directChildren = childrenMap[personId] || [];
                const partnerId = partners[personId];
                const partnerChildren = partnerId ? (childrenMap[partnerId] || []) : [];

                // Merge without duplicates
                const allChildren = [...new Set([...directChildren, ...partnerChildren])];
                return allChildren;
            }

            // 3. Recursive width calculation
            const subtreeWidths = {};
            const processedForWidth = new Set();

            function calculateSubtreeWidth(personId) {
                if (processedForWidth.has(personId)) return 0;
                processedForWidth.add(personId);

                const partnerId = partners[personId];
                if (partnerId) processedForWidth.add(partnerId);

                const children = getDescendants(personId);
                let width = 0;

                if (children.length === 0) {
                    // Width of the unit itself
                    width = partnerId ? HORIZONTAL_SPACING * 1.5 : HORIZONTAL_SPACING;
                } else {
                    let childrenTotalWidth = 0;
                    children.forEach((childId, index) => {
                        childrenTotalWidth += calculateSubtreeWidth(childId);
                        if (index < children.length - 1) childrenTotalWidth += SUBTREE_MARGIN;
                    });

                    const coupleWidth = partnerId ? HORIZONTAL_SPACING * 1.5 : HORIZONTAL_SPACING;
                    width = Math.max(coupleWidth, childrenTotalWidth);
                }

                subtreeWidths[personId] = width;
                if (partnerId) subtreeWidths[partnerId] = width;
                return width;
            }

            // 4. Recursive positioning
            const positioned = new Set();
            function positionNode(personId, x, y) {
                if (positioned.has(personId)) return;
                positioned.add(personId);

                const person = people.find(p => p.id === personId);
                const partnerId = partners[personId];
                const children = getDescendants(personId);

                if (partnerId) {
                    positioned.add(partnerId);
                    const partner = people.find(p => p.id === partnerId);

                    // Position couple centered at x
                    person.x = x - (HORIZONTAL_SPACING * 0.52);
                    person.y = y;
                    partner.x = x + (HORIZONTAL_SPACING * 0.52);
                    partner.y = y;

                    // Position children centered under midpoint
                    if (children.length > 0) {
                        let childrenAreaWidth = 0;
                        children.forEach((cId, idx) => {
                            childrenAreaWidth += subtreeWidths[cId];
                            if (idx < children.length - 1) childrenAreaWidth += SUBTREE_MARGIN;
                        });

                        let currentX = x - (childrenAreaWidth / 2);
                        children.forEach(childId => {
                            const childWidth = subtreeWidths[childId];
                            positionNode(childId, currentX + (childWidth / 2), y + VERTICAL_SPACING);
                            currentX += childWidth + SUBTREE_MARGIN;
                        });
                    }
                } else {
                    // Single parent
                    person.x = x;
                    person.y = y;

                    if (children.length > 0) {
                        let childrenAreaWidth = 0;
                        children.forEach((cId, idx) => {
                            childrenAreaWidth += subtreeWidths[cId];
                            if (idx < children.length - 1) childrenAreaWidth += SUBTREE_MARGIN;
                        });

                        let currentX = x - (childrenAreaWidth / 2);
                        children.forEach(childId => {
                            const childWidth = subtreeWidths[childId];
                            positionNode(childId, currentX + (childWidth / 2), y + VERTICAL_SPACING);
                            currentX += childWidth + SUBTREE_MARGIN;
                        });
                    }
                }
            }

            // 5. Build and execute
            // Identify real roots (not someone's child and not second half of partner pair)
            const roots = people.filter(p => !p.parentId && (!p.partnerId || p.id < p.partnerId));

            roots.forEach(root => calculateSubtreeWidth(root.id));

            let totalRootsWidth = 0;
            roots.forEach((root, idx) => {
                totalRootsWidth += subtreeWidths[root.id];
                if (idx < roots.length - 1) totalRootsWidth += SUBTREE_MARGIN * 4;
            });

            let currentRootX = (window.innerWidth / 2) - (totalRootsWidth / 2);
            roots.forEach(root => {
                const w = subtreeWidths[root.id];
                positionNode(root.id, currentRootX + (w / 2), 100);
                currentRootX += w + SUBTREE_MARGIN * 4;
            });

            offset = { x: 0, y: 0 };
            scale = 1;
            render();
            updateView();
        }

        function updateConnections() {
            svg.innerHTML = '';
            const processedPartners = new Set();

            connections.forEach(conn => {
                const from = people.find(p => p.id === conn.from);
                const to = people.find(p => p.id === conn.to);
                if (!from || !to) return;

                if (conn.type === 'partner') {
                    const pairId = [conn.from, conn.to].sort().join('-');
                    if (processedPartners.has(pairId)) return;
                    processedPartners.add(pairId);

                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    const startX = from.x + 90;
                    const startY = from.y + 40;
                    const endX = to.x + 90;
                    const endY = to.y + 40;

                    path.setAttribute("d", `M ${startX} ${startY} L ${endX} ${endY}`);
                    path.setAttribute("class", "line");
                    path.style.stroke = "var(--secondary)";
                    path.style.strokeDasharray = "5,5";
                    svg.appendChild(path);
                    return;
                }

                if (conn.type === 'child') {
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    let startX = from.x + 90;
                    let startY = from.y + 40;

                    const partner = people.find(p => p.id === from.partnerId);
                    if (partner) {
                        startX = (from.x + partner.x) / 2 + 90;
                        startY = (from.y + partner.y) / 2 + 40;

                        // Junction dot
                        const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                        dot.setAttribute("cx", startX);
                        dot.setAttribute("cy", startY);
                        dot.setAttribute("r", "5");
                        dot.setAttribute("fill", "var(--secondary)");
                        svg.appendChild(dot);
                    }

                    const endX = to.x + 90;
                    const endY = to.y + 40;
                    const midY = (startY + endY) / 2;

                    path.setAttribute("d", `M ${startX} ${startY} L ${startX} ${midY} L ${endX} ${midY} L ${endX} ${endY}`);
                    path.setAttribute("class", "line");
                    svg.appendChild(path);
                }
            });
        }

        function downloadTreeImage() {
            if (people.length === 0) return alert("No hay datos para exportar");

            // 1. Calculate bounding box
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            people.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x + 200);
                maxY = Math.max(maxY, p.y + 100);
            });

            const padding = 100;
            const width = (maxX - minX) + padding * 2;
            const height = (maxY - minY) + padding * 2;

            const canvasExport = document.createElement('canvas');
            canvasExport.width = width;
            canvasExport.height = height;
            const ctx = canvasExport.getContext('2d');

            // 2. Draw Background
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);

            // Grid effect (optional but nice)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x += 50) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke();
            }
            for (let y = 0; y < height; y += 50) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke();
            }

            // 3. Draw Connections
            ctx.lineWidth = 2;
            const processedPartners = new Set();
            connections.forEach(conn => {
                const from = people.find(p => p.id === conn.from);
                const to = people.find(p => p.id === conn.to);
                if (!from || !to) return;

                const startX = from.x - minX + padding + 90;
                const startY = from.y - minY + padding + 40;
                const endX = to.x - minX + padding + 90;
                const endY = to.y - minY + padding + 40;

                if (conn.type === 'partner') {
                    const pairId = [conn.from, conn.to].sort().join('-');
                    if (processedPartners.has(pairId)) return;
                    processedPartners.add(pairId);

                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = '#ec4899';
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (conn.type === 'child') {
                    ctx.strokeStyle = '#94a3b8';
                    ctx.setLineDash([]);

                    let sX = startX;
                    let sY = startY;

                    const partner = people.find(p => p.id === from.partnerId);
                    if (partner) {
                        sX = ((from.x + partner.x) / 2) - minX + padding + 90;
                        sY = ((from.y + partner.y) / 2) - minY + padding + 40;

                        // Junction dot
                        ctx.fillStyle = '#ec4899';
                        ctx.beginPath();
                        ctx.arc(sX, sY, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    const midY = (sY + endY) / 2;
                    ctx.beginPath();
                    ctx.moveTo(sX, sY);
                    ctx.lineTo(sX, midY);
                    ctx.lineTo(endX, midY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            });

            // 4. Draw Nodes
            people.forEach(person => {
                const x = person.x - minX + padding;
                const y = person.y - minY + padding;
                const w = 180;
                const h = 80;

                // Shadow
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetY = 5;

                // Card
                ctx.fillStyle = '#1e293b';
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, 16);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.stroke();

                // Name
                ctx.fillStyle = '#f8fafc';
                ctx.font = 'bold 14px Outfit, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(person.name, x + w / 2, y + 35);

                // Role
                ctx.fillStyle = '#94a3b8';
                ctx.font = '11px Outfit, sans-serif';
                const role = person.parentId ? 'Hijo/a' : (person.partnerId ? 'Pareja' : 'Ra√≠z');
                ctx.fillText(role, x + w / 2, y + 55);
            });

            // 5. Download
            const link = document.createElement('a');
            link.download = `arbol_genealogico_${new Date().getTime()}.png`;
            link.href = canvasExport.toDataURL('image/png');
            link.click();
        }

        function exportData() {
            const data = JSON.stringify({ people, connections, nextId, offset, scale }, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'arbol_familiar.json';
            a.click();
        }

        function handleFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.people && data.connections) {
                        people = data.people;
                        connections = data.connections;
                        nextId = data.nextId || 1;
                        if (data.offset) offset = data.offset;
                        if (data.scale) scale = data.scale;

                        render();
                        updateView();
                        alert("√Årbol cargado con √©xito");
                    } else {
                        alert("El archivo JSON no tiene el formato correcto.");
                    }
                } catch (err) {
                    alert("Error al leer el archivo JSON: " + err.message);
                }
            };
            reader.readAsText(file);
        }

        // Run
        init();

        // Add a default person to start
        people.push({
            id: nextId++,
            name: "Fundador de la Familia",
            x: window.innerWidth / 2 - 90,
            y: 100
        });
        render();

    </script>
</body>

</html>